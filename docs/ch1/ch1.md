## 引入 Introduction

有如下设计的表完成以下业务处理：从数据库中取出一条`FLAG`值为`N`的数据，经过应用处理后，将`FLAG`值修改为`Y`插入数据库。

| id   | name | FLAG |
| ---- | ---- | ---- |
|      |      | Y/N  |

**问题**：数据库中存在大量`FLAG`值为`Y`的数据，查询效率低。

**尝试解决**：换用$bitmap$索引

|       | **1** | **2** | **3** | **4** | **5** |
| ----- | ----- | ----- | ----- | ----- | ----- |
| **Y** | 1     | 0     | 1     | 1     | 0     |
| **N** | 0     | 1     | 0     | 0     | 1     |

**更大的问题**：锁机制导致修改时该数据块无法读取。位图索引使数据很容易被压缩，而数据库按块（页）组织数据。

> $bitmap$(位图索引)不适合**频繁修改**值域有限的字段

**最终解决**：使用函数索引

## 内容大纲 Outline

- 需要理解数据库体系结构
- 需要理解锁和并发控制特性
  - 每个数据库都以不同的方式实现
- 不要把数据库当“黑盒”
- 性能、安全性都是适当的被设计出来的
  - 12306系统数据库设计直接影响性能
- 用尽可能简单的方法解决问题
  - “创造”永远追不上开发的步伐
  - 数据库99%的问题都已经被前人解决了
- DBA和RD之间的关系
  - DBA负责数据库的备份与恢复，程序员对其他职责负责

## 数据库体系结构

 **不能把数据库当成“黑盒”使用，因为每个数据库都是非常不同的**

> Oracle和MySQL的差别，类似：
>
> - Windows和Linux的差别
>
> -  iOS和Android的差别
>
> - 虽然都是DBMS，但它们也有相当的差异

## 并发控制与锁机制

- 这个时候，Transaction1能提交吗？

  ![](image-20240228111424724.png )

Oracle的多版本控制，读一致性的并发模型

- 读一致查询：对于一个时间点（point time），查询会产生一致的结果
- 非阻塞查询：查询不会被写入器阻塞，*但在其它数据库中可能不是这样的*

最简单的验证方式：

![](image-20240228140947506.png)

对于左侧，打开游标时，**不会读取数据，只有在读取游标时才会读取数据**

对于右侧，如果我们删除了所有的表，但是我们在Oracle中仍然可以使用之前打开的游标来读取那个时刻的数据

事实上，打开游标的时候确实没有复制，删除数据的时候也确实删除了，**但是删除数据的时候Oracle为我们使用Undo日志来保存了**下来(我们记作Undo statement)，是删除的回滚段，游标从这类读出数据。

> Oracle认为“读”不那么重要，“读”锁不应该存在。这么实现的好处：有效提高了吞吐量。
>
> Oracle锁机制的相关结论：
>
> 1. 只有修改才加行级锁
>
> 2. Read绝对不会对数据加锁
>
> 3. Writer不会阻塞Reader
>
> 4. 读写器绝对不会阻塞写入器

**例子**：`ACCOUNTS(account_number, account_balance)`一个银行的账户余额，为了简单，只考虑一个仅有四行的表

我们想运行一个日报表，了解银行里有多少钱。下面是一个非常简单的查询：

```sql
select sum(account_balance) from accounts;
```

![](image-20240228140900392.png)

## 打开黑盒

Q：深入了解每个数据库的锁机制实现细节，对码农编码有什么影响嘛？

Oracle的无阻塞设计有一个副作用，就是如果确实想保证一次最多只有一个用户访问一行数据，就得**开发人员自己做一些工作**

**例1**：一个资源调度程序（e.g. 空闲教室查询）主要有两张表:

1. `Resources(Resource_name,other_ data)`
2. `Schedules(resource_ name, start_time, end_time)`

往Schedules中插入一个房间预订之后，提交之前，应用将查询

```sql
Select count(*)
   From schedules
      Where resource_ name =:resource name FOR UPDATE
         and (start_time < :new_end_time) and (end_time > :new_start_time)
```

如果没有`FOR UPDATE`语句，将可能同时读出两条冲突数据：
$$
\begin{split}
  A：(701, 10:00, 12:00) \\
  B：(701, 11:00, 12:00)
\end{split}
$$

要构建一个完全数据库独立的应用，而且是高度可扩展的应用是极其困难的

**例2**：$Null$值造成的数据库迁移障碍

**任务**：在表T中，如果不满足某个条件，则找出X为NULL的所有行，如果满足就找出X等于某个特定值的所有行

> `NULL = NULL` 的返回结果**因数据库而异**，Oracle中`NULL == NULL` 返回 NULL

![](image-20240228114221443.png")

## 数据库设计——性能与安全

**性能调优**：

1. 根据当前CPU能力、可用内存、I/O子系统等资源情况来设置相应参数：DBA在做，性能提高20-30%
2. 通过**索引、物理结构、SQL**的优化，**具体提高某一个查询的性能**

*如果有个专家能通过一些参数、技巧提高了你的系统一个数量级的性能，不能说这个专家牛逼，大概只能说明你的程序太烂了。*

### 性能拙劣的罪魁祸首是错误的设计

- 提高整体性能
  - 技巧决定系统性能的下限
  - 设计决定系统性能的上限

> 比如，新浪新闻的门户网站
>
> - 动态页面vs静态页面
> - **静态页面+内容管理系统**，效率更高、更复杂

衡量性能的指标：任何事务在1s内完成**（×）**

性能指标：T/s, 1秒中能处理多少事务

原因：**阻塞蔓延**，并发量增加时处理速度显著下降

### 使用优化工具

![](image-20240228115141823.png")

定位拥堵点、反向定位程序点

### 整体层面性能优化考虑

**问题一：cpu负载高，io负载低**

- 内存不够

- 磁盘性能差（磁盘问题、raid设计不好、raid降级）

- **SQL的问题**

- **并发锁机制的问题**

- **事务设计问题，大量小数据IO**

- **大量的全表扫描**

**问题二：IO负载高，CPU负载低**

- **大量小的IO执行写操作**

- **Autocommit，产生大量小IO**

- **大量大的IO执行写操作**

- **SQL的问题**

- IO/PS磁盘限定一个每秒最大IO次数

**问题三：IO和CPU负载都高**

- 硬件不够用了

- **SQL存在问题**

*性能问题，90%的问题来源都是程序员的问题*

*开发环境到生产环境是一场灾难*