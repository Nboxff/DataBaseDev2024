## 事务处理（复习）

### ACID 事务

处理必须遵循的原则

- 原子性 *事务的本质要求*
- 一致性 *数据完整的本质要求，唯一一个可以由开发者控制而不是凭数据库自身保证的属性*
- 隔离性 *并发的本质要求*
- 持久性 *数据库系统的本质要求*

### 事务处理的组件

- 事务管理器
- 锁管理器
- 页缓存
- 日志管理器
- 分布式事务协调

## 缓冲区管理

### 不使用OS

为什么要自己实现缓存池，而不使用操作系统的$mmap$

- dirty pages事务性写回
- 预存数据
- 定制替换策略
- 线程/进程调度

DBMS告诉OS， 不要缓存这些数据 -> **Direct I/O**

### Buffer Pool Manager

DBMS维护一个页表`page table`, 记录page在内存中的位置、Dirty Flag、引用计数（使用该page的线程数）

页表本质是一个哈希表，通过**页表**和**page id**可以确定在哪一个frame中

### 替换策略

1. FIFO先进先出

2. LRU：Least Recently Used 最近最少使用算法 *时间戳最老*

   实现：维护一个队列，读写page放入队尾，队首page被换出

3. Clock时钟：LRU的近似算法

   > LRU算法和Clock时钟算法的问题：存在顺序洪水问题。当顺序扫描大量一次性的page时，非常常用的page可能会被换出。

4. LRU-K算法，最近使用过K次

   $K$是对单个page对应缓存数据的访问进行计数的次数

### 脏页

脏页被换出需要写回到磁盘

后台写：后台线程定期扫描page table， 将脏页写入磁盘，标记为干净

## 恢复（Recovery）

### 为什么需要Redo日志

> Buffer Pool和Disk的双存储机制必须协R同，对于一个已经提交的事务，在事务提交后即使数据库发生崩溃，事务的更改也不应该丢失，应该如何实现呢？

最简单的方法是——在事务提交完成之前，把该事务所有页面都刷新到磁盘

存在的问题：

- 刷新一个完整的数据页太浪费了，如果只修改了一个字节，却要刷一个完整的16K的页面
- 随机I/O的刷新效率不高

所以需要日志R（Redo和Undo）

Redo log（重做日志）：1. 占用空间很小 2. 顺序写入磁盘（顺序I/O）

### Redo日志的设计

- 静态结构

  - redo日志的结构

  - redo日志页需不需要设置大小？要不要比正常的Page**大**或者小？

    > 顺序追加、追求写的效率、大量读->Page比正常的大 (达到512KB)

  - redo日志是顺序组织还是随机组织

- 动态结构

  - 事务的原子性如何保证？冲突如何控制？
  - redo日志也是双存储结构，应该如何刷写

- 维护实现

  - 如何循环使用redo

#### 静态结构——page日志格式

| type | Space ID | Page number | data |
| ---- | -------- | ----------- | ---- |
|      |          |             |      |

- type：日志类型（MYSQL共53种）

- Space ID：表空间ID

- Page number：页ID

- Data：日志的就内容

一条SQL语句会修改很多地方（大量索引的更新）

- 方案1：在每个修改的地方都记录一条redo日志

- 方案2：将整个页面第一个被修改的字节到最后一个被修改的字节之间所有的数据，当成一条物理redo日志的具体数据
- 方案3：**只记录操作**，不记录物理变化

物理层面和逻辑层面的融合日志格式

- 记录本页面插入一条记录的必备物理要素记录下来
- 但不去管Page这一层面的系统值
- 日志本质上调用恢复函数的参数组

> 补充Copy-On-Write的缺点：深度较高时，复制代价较大

Mini-Transacition

以组的形式写入redo日志

- 一组操作，一组日志的不可分割性

- 增加一个特殊类型的redo日志（MySQL）

  Redo 0 Redo 1 Redo 2 ... Redo n

```
事务
├── 语句1
│   ├── MTR1
│   │   ├── redo0
│   │   ├── redo1
│   │   ├── redo2
│   │   └── redo3
│   ├── MTR2
│   └── MTR3
├── 语句2
└── 语句3
```

#### 动态结构——日志缓冲

- redo日志依旧时双存储结构，有独立的buffer，由若干连续redo log block组成
- 设置全局变量指向空闲区

lsn值 (log sequence number)

- 总要记录哪些log已经刷写了，哪些log尚未刷写
- 对大多数数据库来说，需要由一个全局log变量定位位置

三个全局变量：写到哪了，刷写到哪了，哪些已经执行了

redo log的刷盘时机是什么呢？（多选题）

- log buffer 空间不足
- 事务提交时
- 脏页刷新
- 定时进程，固定频率刷新
- 正常关闭服务器

> 全选，嘻嘻

#### Check point

redo日志组容量是有限的，不得不循环使用redo日志文件组的文件

buffer中如何知道哪些日志组已经刷写到磁盘了，哪些日志组的操作已经写到数据文件中了

后台刷脏操作和check point操作时两个并行的操作

### 恢复

- 确定恢复的起点
  - 选取最近发生的那次的checkpoint的信息，checkpoint_no比较一下大小
  - 然后找checkpoint_lsn以及checkpoint_offset
- 确定恢复的终点
  - 找没写满的那个

### Undo日志

事务保证原子性靠的就是日志

- 错误：服务器、操作系统、断电
- 手动或自动rollback

所有的操作都是预写日志WAL

WAL时仅追加的， LSN单调递增，强制刷盘操作、事务管理器、页缓存触发

被修改的Undo记录本身，也会记录Redo log